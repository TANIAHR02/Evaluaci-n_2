"""
SchoolBot Agent - Test Suite
Suite de Pruebas para el Agente Inteligente Escolar

Autor: Tania Herrera
Fecha: Diciembre 2024
Evaluaci√≥n: EP2 - Ingenier√≠a de Soluciones con IA
"""

import os
import sys
import json
import time
import unittest
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional

# Agregar path del proyecto
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Importar componentes del agente
from src.agent.orchestrator import AgentOrchestrator, create_agent_orchestrator
from src.agent.config import get_complete_config
from src.agent.memory_manager import MemoryManager
from src.agent.planning_engine import PlanningEngine
from src.agent.tools import QueryTool, WritingTool, ReasoningTool

class TestSchoolBotAgent(unittest.TestCase):
    """Suite de pruebas para el agente SchoolBot"""
    
    def setUp(self):
        """Configuraci√≥n inicial para cada prueba"""
        self.config = get_complete_config("profesor", "testing")
        self.orchestrator = None
        self.session_id = None
        
    def tearDown(self):
        """Limpieza despu√©s de cada prueba"""
        if self.orchestrator:
            self.orchestrator.shutdown()
    
    def test_01_orchestrator_initialization(self):
        """Prueba: Inicializaci√≥n del orquestador"""
        print("\nüß™ PRUEBA 1: Inicializaci√≥n del Orquestador")
        
        try:
            self.orchestrator = create_agent_orchestrator()
            self.assertIsNotNone(self.orchestrator, "Orquestador no inicializado")
            
            # Verificar componentes
            self.assertIsNotNone(self.orchestrator.agent, "Agente principal no inicializado")
            self.assertIsNotNone(self.orchestrator.agent.memory_manager, "Gestor de memoria no inicializado")
            self.assertIsNotNone(self.orchestrator.agent.planning_engine, "Motor de planificaci√≥n no inicializado")
            
            print("‚úÖ Orquestador inicializado correctamente")
            
        except Exception as e:
            self.fail(f"Error inicializando orquestador: {str(e)}")
    
    def test_02_session_creation(self):
        """Prueba: Creaci√≥n de sesi√≥n de usuario"""
        print("\nüß™ PRUEBA 2: Creaci√≥n de Sesi√≥n")
        
        try:
            self.orchestrator = create_agent_orchestrator()
            
            # Crear sesi√≥n
            self.session_id = self.orchestrator.create_session(
                user_id="test_profesor",
                user_type="profesor",
                context={"test": True}
            )
            
            self.assertIsNotNone(self.session_id, "ID de sesi√≥n no generado")
            self.assertIn(self.session_id, self.orchestrator.sessions, "Sesi√≥n no almacenada")
            
            # Verificar datos de sesi√≥n
            session = self.orchestrator.sessions[self.session_id]
            self.assertEqual(session.user_id, "test_profesor")
            self.assertEqual(session.user_type, "profesor")
            
            print(f"‚úÖ Sesi√≥n creada: {self.session_id}")
            
        except Exception as e:
            self.fail(f"Error creando sesi√≥n: {str(e)}")
    
    def test_03_simple_query(self):
        """Prueba: Consulta simple"""
        print("\nüß™ PRUEBA 3: Consulta Simple")
        
        try:
            self.orchestrator = create_agent_orchestrator()
            self.session_id = self.orchestrator.create_session("test_user", "estudiante")
            
            request = "¬øCu√°les son los horarios de clases del colegio?"
            start_time = time.time()
            
            response = self.orchestrator.process_request(self.session_id, request)
            
            processing_time = time.time() - start_time
            
            # Verificaciones
            self.assertIsNotNone(response, "Respuesta no generada")
            self.assertIn("response", response, "Campo 'response' faltante")
            self.assertLess(processing_time, 10.0, f"Tiempo de procesamiento muy alto: {processing_time:.2f}s")
            
            print(f"‚úÖ Consulta procesada en {processing_time:.2f}s")
            print(f"üìù Respuesta: {response['response'][:100]}...")
            
        except Exception as e:
            self.fail(f"Error en consulta simple: {str(e)}")
    
    def test_04_complex_task_planning(self):
        """Prueba: Tarea compleja con planificaci√≥n"""
        print("\nüß™ PRUEBA 4: Tarea Compleja con Planificaci√≥n")
        
        try:
            self.orchestrator = create_agent_orchestrator()
            self.session_id = self.orchestrator.create_session("test_profesor", "profesor")
            
            request = """
            Necesito generar un reporte acad√©mico completo para el estudiante Juan P√©rez del curso 3¬∞A, 
            incluyendo an√°lisis de rendimiento y recomendaciones de mejora
            """
            
            start_time = time.time()
            response = self.orchestrator.process_request(self.session_id, request)
            processing_time = time.time() - start_time
            
            # Verificaciones
            self.assertIsNotNone(response, "Respuesta no generada")
            self.assertIn("plan", response, "Plan no generado")
            
            plan = response["plan"]
            self.assertIsNotNone(plan, "Plan es None")
            self.assertIn("steps", plan, "Pasos del plan faltantes")
            self.assertGreater(len(plan["steps"]), 1, "Plan debe tener m√∫ltiples pasos")
            
            print(f"‚úÖ Plan creado con {len(plan['steps'])} pasos")
            print(f"‚è±Ô∏è Tiempo de procesamiento: {processing_time:.2f}s")
            
            # Mostrar pasos del plan
            for i, step in enumerate(plan["steps"], 1):
                print(f"   {i}. {step.get('description', 'Sin descripci√≥n')}")
                print(f"      Herramienta: {step.get('tool', 'N/A')}")
            
        except Exception as e:
            self.fail(f"Error en tarea compleja: {str(e)}")
    
    def test_05_memory_persistence(self):
        """Prueba: Persistencia de memoria"""
        print("\nüß™ PRUEBA 5: Persistencia de Memoria")
        
        try:
            self.orchestrator = create_agent_orchestrator()
            self.session_id = self.orchestrator.create_session("test_user", "estudiante")
            
            # Primera consulta
            request1 = "¬øCu√°ndo son las vacaciones de invierno?"
            response1 = self.orchestrator.process_request(self.session_id, request1)
            
            # Segunda consulta que deber√≠a usar memoria
            request2 = "¬øY las vacaciones de verano?"
            response2 = self.orchestrator.process_request(self.session_id, request2)
            
            # Verificaciones
            self.assertIsNotNone(response1, "Primera respuesta no generada")
            self.assertIsNotNone(response2, "Segunda respuesta no generada")
            
            # Verificar estado de memoria
            agent_status = self.orchestrator.get_agent_status()
            memory_status = agent_status.get("agent_status", {}).get("memory_status")
            
            if memory_status:
                stats = memory_status.get("stats", {})
                self.assertGreater(stats.get("total_entries", 0), 0, "No hay entradas en memoria")
                
                print(f"üìä Estado de memoria:")
                print(f"   - Entradas totales: {stats.get('total_entries', 0)}")
                print(f"   - Memoria de corto plazo: {stats.get('short_term_entries', 0)}")
                print(f"   - Memoria de largo plazo: {stats.get('long_term_entries', 0)}")
            
            print("‚úÖ Memoria funcionando correctamente")
            
        except Exception as e:
            self.fail(f"Error en prueba de memoria: {str(e)}")
    
    def test_06_writing_tool(self):
        """Prueba: Herramienta de escritura"""
        print("\nüß™ PRUEBA 6: Herramienta de Escritura")
        
        try:
            self.orchestrator = create_agent_orchestrator()
            self.session_id = self.orchestrator.create_session("test_profesor", "profesor")
            
            request = """
            Genera un comunicado para los apoderados informando sobre la pr√≥xima reuni√≥n de padres 
            del 15 de diciembre a las 19:00 horas en el auditorio principal
            """
            
            response = self.orchestrator.process_request(self.session_id, request)
            
            # Verificaciones
            self.assertIsNotNone(response, "Respuesta no generada")
            self.assertIn("response", response, "Campo 'response' faltante")
            
            response_text = response["response"]
            self.assertGreater(len(response_text), 50, "Respuesta muy corta")
            
            # Verificar contenido del comunicado
            self.assertIn("COMUNICADO", response_text.upper(), "No es un comunicado")
            self.assertIn("APODERADOS", response_text.upper(), "No menciona apoderados")
            
            print("‚úÖ Comunicado generado correctamente")
            print(f"üìÑ Longitud: {len(response_text)} caracteres")
            print(f"üìù Contenido: {response_text[:200]}...")
            
        except Exception as e:
            self.fail(f"Error en herramienta de escritura: {str(e)}")
    
    def test_07_reasoning_tool(self):
        """Prueba: Herramienta de razonamiento"""
        print("\nüß™ PRUEBA 7: Herramienta de Razonamiento")
        
        try:
            self.orchestrator = create_agent_orchestrator()
            self.session_id = self.orchestrator.create_session("test_profesor", "profesor")
            
            request = """
            Analiza las siguientes opciones para mejorar el rendimiento acad√©mico: 
            1) Implementar tutor√≠as personalizadas, 2) Crear grupos de estudio, 3) Usar tecnolog√≠a educativa. 
            Considera costos, tiempo y efectividad.
            """
            
            response = self.orchestrator.process_request(self.session_id, request)
            
            # Verificaciones
            self.assertIsNotNone(response, "Respuesta no generada")
            self.assertIn("response", response, "Campo 'response' faltante")
            
            response_text = response["response"]
            self.assertGreater(len(response_text), 100, "An√°lisis muy corto")
            
            # Verificar que es un an√°lisis
            analysis_keywords = ["an√°lisis", "opciones", "recomendaci√≥n", "ventajas", "desventajas"]
            has_analysis = any(keyword in response_text.lower() for keyword in analysis_keywords)
            self.assertTrue(has_analysis, "No parece ser un an√°lisis")
            
            print("‚úÖ An√°lisis generado correctamente")
            print(f"üìä Longitud: {len(response_text)} caracteres")
            print(f"üìù Contenido: {response_text[:200]}...")
            
        except Exception as e:
            self.fail(f"Error en herramienta de razonamiento: {str(e)}")
    
    def test_08_adaptive_behavior(self):
        """Prueba: Comportamiento adaptativo"""
        print("\nüß™ PRUEBA 8: Comportamiento Adaptativo")
        
        try:
            self.orchestrator = create_agent_orchestrator()
            self.session_id = self.orchestrator.create_session("test_user", "estudiante")
            
            # Diferentes tipos de solicitudes
            requests = [
                "¬øQu√© necesito para matricularme?",
                "Genera un reporte de asistencia",
                "Analiza las calificaciones del curso 2¬∞B",
                "¬øCu√°ndo es la pr√≥xima reuni√≥n de apoderados?"
            ]
            
            responses = []
            
            for i, request in enumerate(requests, 1):
                print(f"   üìù Solicitud {i}: {request[:50]}...")
                
                response = self.orchestrator.process_request(self.session_id, request)
                responses.append(response)
                
                # Verificar an√°lisis
                analysis = response.get("analysis", {})
                self.assertIsNotNone(analysis, f"An√°lisis faltante para solicitud {i}")
                
                print(f"      üìä Complejidad: {analysis.get('complexity', 'N/A')}")
                print(f"      üõ†Ô∏è Herramientas: {analysis.get('tools_needed', [])}")
                print(f"      üéØ Intenci√≥n: {analysis.get('intent', 'N/A')}")
            
            print("‚úÖ Comportamiento adaptativo funcionando")
            
        except Exception as e:
            self.fail(f"Error en comportamiento adaptativo: {str(e)}")
    
    def test_09_system_metrics(self):
        """Prueba: M√©tricas del sistema"""
        print("\nüß™ PRUEBA 9: M√©tricas del Sistema")
        
        try:
            self.orchestrator = create_agent_orchestrator()
            self.session_id = self.orchestrator.create_session("test_user", "profesor")
            
            # Ejecutar algunas solicitudes para generar m√©tricas
            test_requests = [
                "¬øCu√°les son los horarios?",
                "Genera un comunicado",
                "Analiza el rendimiento acad√©mico"
            ]
            
            for request in test_requests:
                self.orchestrator.process_request(self.session_id, request)
            
            # Obtener m√©tricas
            status = self.orchestrator.get_agent_status()
            metrics = status.get("system_metrics", {})
            
            # Verificaciones
            self.assertGreater(metrics.get("total_requests", 0), 0, "No hay solicitudes registradas")
            self.assertGreater(metrics.get("successful_requests", 0), 0, "No hay solicitudes exitosas")
            self.assertGreater(metrics.get("average_response_time", 0), 0, "Tiempo promedio no calculado")
            
            print("üìà M√©tricas del Sistema:")
            print(f"   - Solicitudes totales: {metrics.get('total_requests', 0)}")
            print(f"   - Solicitudes exitosas: {metrics.get('successful_requests', 0)}")
            print(f"   - Solicitudes fallidas: {metrics.get('failed_requests', 0)}")
            print(f"   - Tiempo promedio: {metrics.get('average_response_time', 0):.2f}s")
            print(f"   - Sesiones activas: {metrics.get('active_sessions', 0)}")
            
            print("‚úÖ M√©tricas funcionando correctamente")
            
        except Exception as e:
            self.fail(f"Error en m√©tricas del sistema: {str(e)}")
    
    def test_10_error_handling(self):
        """Prueba: Manejo de errores"""
        print("\nüß™ PRUEBA 10: Manejo de Errores")
        
        try:
            self.orchestrator = create_agent_orchestrator()
            self.session_id = self.orchestrator.create_session("test_user", "estudiante")
            
            # Solicitud con error intencional
            invalid_request = ""  # Solicitud vac√≠a
            
            response = self.orchestrator.process_request(self.session_id, invalid_request)
            
            # Verificar manejo de error
            self.assertIsNotNone(response, "Respuesta no generada")
            
            # Debe manejar el error graciosamente
            if "error" in response:
                print(f"‚úÖ Error manejado correctamente: {response['error']}")
            else:
                print("‚úÖ Sistema maneja solicitudes vac√≠as sin errores")
            
            # Probar con sesi√≥n inexistente
            try:
                self.orchestrator.process_request("session_inexistente", "test")
                self.fail("Deber√≠a haber fallado con sesi√≥n inexistente")
            except ValueError as e:
                print(f"‚úÖ Error de sesi√≥n manejado: {str(e)}")
            
            print("‚úÖ Manejo de errores funcionando correctamente")
            
        except Exception as e:
            self.fail(f"Error en manejo de errores: {str(e)}")

class TestMemoryManager(unittest.TestCase):
    """Pruebas espec√≠ficas para el gestor de memoria"""
    
    def setUp(self):
        """Configuraci√≥n inicial"""
        self.config = {
            "memory_path": "data/test_memory",
            "max_short_term": 10,
            "max_long_term": 50
        }
        self.memory_manager = None
    
    def tearDown(self):
        """Limpieza"""
        if self.memory_manager:
            self.memory_manager.clear_memory()
    
    def test_memory_storage(self):
        """Prueba: Almacenamiento en memoria"""
        print("\nüß™ PRUEBA MEMORIA: Almacenamiento")
        
        try:
            self.memory_manager = MemoryManager(self.config)
            
            # Almacenar interacci√≥n
            interaction = {
                "request": "¬øCu√°les son los horarios?",
                "response": "Las clases son de 8:00 a 16:00",
                "analysis": {"complexity": "simple"},
                "context": {"user_type": "estudiante"}
            }
            
            self.memory_manager.store_interaction(interaction)
            
            # Verificar almacenamiento
            status = self.memory_manager.get_status()
            self.assertGreater(status["stats"]["total_entries"], 0, "No se almacen√≥ la interacci√≥n")
            
            print("‚úÖ Interacci√≥n almacenada correctamente")
            
        except Exception as e:
            self.fail(f"Error almacenando en memoria: {str(e)}")
    
    def test_memory_retrieval(self):
        """Prueba: Recuperaci√≥n de memoria"""
        print("\nüß™ PRUEBA MEMORIA: Recuperaci√≥n")
        
        try:
            self.memory_manager = MemoryManager(self.config)
            
            # Almacenar varias interacciones
            interactions = [
                {"request": "horarios de clases", "response": "8:00 a 16:00"},
                {"request": "vacaciones de invierno", "response": "24 junio al 7 julio"},
                {"request": "documentos matr√≠cula", "response": "certificado, fotocopia"}
            ]
            
            for interaction in interactions:
                self.memory_manager.store_interaction(interaction)
            
            # Recuperar memoria
            results = self.memory_manager.retrieve_memory("horarios", limit=3)
            
            self.assertIsNotNone(results, "No se recuper√≥ memoria")
            self.assertGreater(len(results), 0, "No hay resultados de memoria")
            
            print(f"‚úÖ Memoria recuperada: {len(results)} entradas")
            
        except Exception as e:
            self.fail(f"Error recuperando memoria: {str(e)}")

class TestPlanningEngine(unittest.TestCase):
    """Pruebas espec√≠ficas para el motor de planificaci√≥n"""
    
    def setUp(self):
        """Configuraci√≥n inicial"""
        self.config = {
            "max_plan_steps": 5,
            "default_timeout": 60
        }
        self.planning_engine = None
    
    def test_plan_creation(self):
        """Prueba: Creaci√≥n de planes"""
        print("\nüß™ PRUEBA PLANIFICACI√ìN: Creaci√≥n de Planes")
        
        try:
            self.planning_engine = PlanningEngine(self.config)
            
            # Crear contexto de decisi√≥n
            from src.agent.planning_engine import DecisionContext
            context = DecisionContext(
                user_type="profesor",
                task_complexity="complex",
                available_tools=["query", "writing", "reasoning"],
                memory_context={},
                constraints={},
                preferences={}
            )
            
            # Crear plan
            request = "Generar reporte acad√©mico completo"
            analysis = {
                "complexity": "complex",
                "tools_needed": ["query", "reasoning", "writing"],
                "intent": "document_generation"
            }
            
            plan = self.planning_engine.create_plan(request, analysis, context)
            
            self.assertIsNotNone(plan, "Plan no creado")
            self.assertIn("steps", plan, "Pasos del plan faltantes")
            self.assertGreater(len(plan["steps"]), 0, "Plan sin pasos")
            
            print(f"‚úÖ Plan creado con {len(plan['steps'])} pasos")
            
        except Exception as e:
            self.fail(f"Error creando plan: {str(e)}")

def run_performance_test():
    """Prueba de rendimiento del sistema"""
    print("\nüöÄ PRUEBA DE RENDIMIENTO")
    print("="*50)
    
    try:
        orchestrator = create_agent_orchestrator()
        session_id = orchestrator.create_session("perf_test", "profesor")
        
        # Solicitudes de prueba
        test_requests = [
            "¬øCu√°les son los horarios de clases?",
            "¬øCu√°ndo son las vacaciones de invierno?",
            "Genera un comunicado para apoderados",
            "Analiza el rendimiento acad√©mico del curso 3¬∞A",
            "¬øQu√© documentos necesito para la matr√≠cula?"
        ]
        
        total_time = 0
        successful_requests = 0
        
        for i, request in enumerate(test_requests, 1):
            print(f"üìù Solicitud {i}: {request}")
            
            start_time = time.time()
            response = orchestrator.process_request(session_id, request)
            processing_time = time.time() - start_time
            
            total_time += processing_time
            
            if response and not response.get("error"):
                successful_requests += 1
                print(f"   ‚úÖ Procesada en {processing_time:.2f}s")
            else:
                print(f"   ‚ùå Error: {response.get('error', 'Desconocido')}")
        
        # M√©tricas finales
        avg_time = total_time / len(test_requests)
        success_rate = (successful_requests / len(test_requests)) * 100
        
        print(f"\nüìä RESULTADOS DE RENDIMIENTO:")
        print(f"   - Solicitudes procesadas: {len(test_requests)}")
        print(f"   - Solicitudes exitosas: {successful_requests}")
        print(f"   - Tasa de √©xito: {success_rate:.1f}%")
        print(f"   - Tiempo total: {total_time:.2f}s")
        print(f"   - Tiempo promedio: {avg_time:.2f}s")
        
        # Verificar objetivos
        if success_rate >= 90:
            print("‚úÖ Objetivo de tasa de √©xito cumplido (‚â•90%)")
        else:
            print("‚ùå Objetivo de tasa de √©xito no cumplido")
        
        if avg_time <= 5.0:
            print("‚úÖ Objetivo de tiempo promedio cumplido (‚â§5s)")
        else:
            print("‚ùå Objetivo de tiempo promedio no cumplido")
        
        orchestrator.shutdown()
        
    except Exception as e:
        print(f"‚ùå Error en prueba de rendimiento: {str(e)}")

def main():
    """Funci√≥n principal para ejecutar todas las pruebas"""
    print("üß™ INICIANDO SUITE DE PRUEBAS - SCHOOLBOT AGENT")
    print("="*60)
    
    # Crear suite de pruebas
    test_suite = unittest.TestSuite()
    
    # Agregar pruebas del agente principal
    test_suite.addTest(unittest.makeSuite(TestSchoolBotAgent))
    test_suite.addTest(unittest.makeSuite(TestMemoryManager))
    test_suite.addTest(unittest.makeSuite(TestPlanningEngine))
    
    # Ejecutar pruebas
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(test_suite)
    
    # Mostrar resumen
    print("\n" + "="*60)
    print("üìä RESUMEN DE PRUEBAS")
    print("="*60)
    print(f"Pruebas ejecutadas: {result.testsRun}")
    print(f"Pruebas exitosas: {result.testsRun - len(result.failures) - len(result.errors)}")
    print(f"Pruebas fallidas: {len(result.failures)}")
    print(f"Errores: {len(result.errors)}")
    
    if result.failures:
        print("\n‚ùå PRUEBAS FALLIDAS:")
        for test, traceback in result.failures:
            print(f"   - {test}: {traceback}")
    
    if result.errors:
        print("\n‚ùå ERRORES:")
        for test, traceback in result.errors:
            print(f"   - {test}: {traceback}")
    
    # Ejecutar prueba de rendimiento
    run_performance_test()
    
    print("\n‚úÖ SUITE DE PRUEBAS COMPLETADA")

if __name__ == "__main__":
    main()
